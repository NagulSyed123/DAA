#include <stdio.h>
#include <limits.h>
#define MAX 100
int heap[MAX], pos[MAX], dist[MAX], size, n;
int graph[MAX][MAX];
void swap(int *a, int *b) {
int t = *a; *a = *b; *b = t;
}
void min_heapify(int i) {
int l = 2*i + 1, r = 2*i + 2, smallest = i;
if (l < size && dist[heap[l]] < dist[heap[smallest]]) smallest = l;
if (r < size && dist[heap[r]] < dist[heap[smallest]]) smallest = r;
if (smallest != i) {
pos[heap[i]] = smallest;
pos[heap[smallest]] = i;
swap(&heap[i], &heap[smallest]);
min_heapify(smallest);
}
}
void build_heap() {
for (int i = (size/2)-1; i >= 0; i--)
min_heapify(i);
}
int extract_min() {
if (size == 0) return -1;
int root = heap[0];
heap[0] = heap[size - 1];
pos[heap[0]] = 0;
size--;
min_heapify(0);
return root;
}
void decrease_key(int v, int new_dist) {
dist[v] = new_dist;
int i = pos[v];
while (i > 0 && dist[heap[(i-1)/2]] > dist[heap[i]]) {
pos[heap[i]] = (i-1)/2;
pos[heap[(i-1)/2]] = i;
swap(&heap[i], &heap[(i-1)/2]);
i = (i-1)/2;
}
}
void dijkstra(int src) {
size = n;
for (int i = 0; i < n; i++) {
heap[i] = i;
pos[i] = i;
dist[i] = INT_MAX;
}
dist[src] = 0;
build_heap();
while (size > 0) {
int u = extract_min();
for (int v = 0; v < n; v++) {
if (graph[u][v] && dist[u] != INT_MAX && dist[u] + graph[u][v] < dist[v]) {
decrease_key(v, dist[u] + graph[u][v]);
}
}
}
}
int main() {
n = 6;
int G[6][6] = {
    {0, 5, 0, 0, 9, 0},
    {0, 0, 2, 3, 0, 0},
    {0, 0, 0, 7, 0, 4},
    {0, 0, 0, 0, 0, 2},
    {0, 0, 0, 6, 0, 1},
    {0, 0, 0, 0, 0, 0}
};};
for (int i = 0; i < n; i++)
for (int j = 0; j < n; j++)
graph[i][j] = G[i][j];
int src = 0;
dijkstra(src);
printf("Vertex\tDistance from Source\n");
for (int i = 0; i < n; i++)
printf("%d\t%d\n", i, dist[i]);
return 0;
}
